/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2023 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2023-05-26
 *
 */

import 'dart:math';

import 'package:decimal/decimal.dart';
import 'package:uuid/uuid.dart';

import '../../../app_config.dart';
import '../../../exceptions/exchange/exchange_exception.dart';
import '../../../models/exchange/response_objects/estimate.dart';
import '../../../models/exchange/response_objects/range.dart';
import '../../../models/exchange/response_objects/trade.dart';
import '../../../models/isar/exchange_cache/currency.dart';
import '../../../models/isar/exchange_cache/pair.dart';
import '../exchange.dart';
import '../exchange_response.dart';
import 'api_response_models/cf_currency.dart';
import 'api_response_models/cf_estimate.dart';
import 'chainflip_api.dart';

class ChainflipExchange extends Exchange {
  ChainflipExchange._();

  static ChainflipExchange? _instance;
  static ChainflipExchange get instance => _instance ??= ChainflipExchange._();

  static const exchangeName = "Chainflip";

  List<CFCurrency>? supportedCurrencies;

  @override
  String get name => exchangeName;

  @override
  bool get supportsRefundAddress => true;

  @override
  Future<ExchangeResponse<List<Currency>>> getAllCurrencies(
    bool fixedRate,
  ) async {
    try {
      if (fixedRate) {
        throw ExchangeException(
          "Chainflip fixedRate not available",
          ExchangeExceptionType.generic,
        );
      }

      if (supportedCurrencies == null) {
        final response = await ChainflipAPI.instance.getSupportedCurrencies();

        if (response.exception != null) {
          return ExchangeResponse(
            exception: response.exception,
          );
        }

        supportedCurrencies = response.value!;
      }

      return ExchangeResponse(
        value: supportedCurrencies!
            .map(
              (e) => Currency(
                exchangeName: exchangeName,
                externalId: e.id,
                ticker: e.ticker,
                name: e.name,
                network: e.network,
                image: e.image,
                isFiat: false,
                rateType: SupportedRateType.estimated,
                isStackCoin: AppConfig.isStackCoin(e.ticker),
                tokenContract: null,
                isAvailable: true,
              ),
            )
            .toList(),
      );
    } on ExchangeException catch (e) {
      return ExchangeResponse(
        exception: e,
      );
    } catch (e) {
      return ExchangeResponse(
        exception: ExchangeException(
          e.toString(),
          ExchangeExceptionType.generic,
        ),
      );
    }
  }

  @override
  Future<ExchangeResponse<List<Currency>>> getPairedCurrencies(
    String forCurrency,
    bool fixedRate,
  ) async {
    throw UnimplementedError();
  }

  @override
  Future<ExchangeResponse<List<Pair>>> getPairsFor(
    String currency,
    bool fixedRate,
  ) async {
    throw UnsupportedError("Not used");
  }

  @override
  Future<ExchangeResponse<List<Pair>>> getAllPairs(bool fixedRate) async {
    throw UnimplementedError();
  }

  @override
  Future<ExchangeResponse<Trade>> getTrade(String tradeId) async {
    throw UnimplementedError();
  }

  @override
  Future<ExchangeResponse<Trade>> updateTrade(Trade trade) async {
    throw UnimplementedError();
  }

  @override
  Future<ExchangeResponse<List<Trade>>> getTrades() async {
    throw UnimplementedError();
  }

  @override
  Future<ExchangeResponse<Range>> getRange(
    String from,
    String to,
    bool fixedRate,
  ) async {
    try {
      if (fixedRate) {
        throw ExchangeException(
          "Chainflip fixedRate not available",
          ExchangeExceptionType.generic,
        );
      }

      if (supportedCurrencies == null) {
        final response = await ChainflipAPI.instance.getSupportedCurrencies();

        if (response.exception != null) {
          return ExchangeResponse(
            exception: response.exception,
          );
        }

        supportedCurrencies = response.value!;
      }

      CFCurrency? currency = supportedCurrencies!.cast<CFCurrency?>().firstWhere(
          (c) => c?.ticker == from,
          orElse: () => null,
        );

      if (currency == null)
      {
        return ExchangeResponse(
          value: Range(
            min: null,
            max: null,
          ),
        );
      } else {
        return ExchangeResponse(
          value: Range(
            min: Decimal.parse(currency.minAmount.toString()),
            max: null,
          ),
        );
      }
    } on ExchangeException catch (e) {
      return ExchangeResponse(
        exception: e,
      );
    } catch (e) {
      return ExchangeResponse(
        exception: ExchangeException(
          e.toString(),
          ExchangeExceptionType.generic,
        ),
      );
    }
  }

  @override
  Future<ExchangeResponse<List<Estimate>>> getEstimates(
    String from,
    String to,
    Decimal amount,
    bool fixedRate,
    bool reversed,
  ) async {
    try {
      if (fixedRate) {
        throw ExchangeException(
          "Chainflip fixedRate not available",
          ExchangeExceptionType.generic,
        );
      }

      if (reversed) {
        throw ExchangeException(
          "Chainflip does not support reversed estimates",
          ExchangeExceptionType.generic,
        );
      }

      final ExchangeResponse<CFEstimate> response = 
        await ChainflipAPI.instance.getEstimate(
          from: from,
          to: to,
          amountFrom: amount.toString(),
        );

      if (response.exception != null) {
        return ExchangeResponse(
          exception: response.exception,
        );
      }

      final t = response.value!;

      return ExchangeResponse(
        value: [
          Estimate(
            estimatedAmount: Decimal.parse(t.amountTo.toString()),
            fixedRate: fixedRate,
            reversed: reversed,
            exchangeProvider: exchangeName,
          ),
        ],
      );
    } on ExchangeException catch (e) {
      return ExchangeResponse(
        exception: e,
      );
    } catch (e) {
      return ExchangeResponse(
        exception: ExchangeException(
          e.toString(),
          ExchangeExceptionType.generic,
        ),
      );
    }
  }

  @override
  Future<ExchangeResponse<Trade>> createTrade({
    required String from,
    required String to,
    required bool fixedRate,
    required Decimal amount,
    required String addressTo,
    String? extraId,
    required String addressRefund,
    required String refundExtraId,
    Estimate? estimate,
    required bool reversed,
  }) async {
    throw UnimplementedError();
  }

  // Chainflip does not support tor.
  @override
  bool get supportsTor => false;
}
